/*
  ==============================================================================

    SamplerAudioSource.h
    Created: 27 Mar 2020 9:20:18am
    Author:  azohc

  ==============================================================================
*/

#pragma once

#include "../JuceLibraryCode/JuceHeader.h"
#include "../../Sampler/Source/SamplerSynthVoice.h"
#include "../../Sampler/Source/SamplerSynthSound.h"
#include "../../Sampler/Source/Constants.h"

//==============================================================================
/*
*/
class SamplerAudioSource    : public AudioSource
{
public:
    SamplerAudioSource (MidiKeyboardState& keyState, ValueTree chops, 
                        AudioFormatReaderSource * audioReaderSource) : keyboardState (keyState), chopTree (chops)
    {
        // Add some voices to our synth, to play the sounds..
        for (auto i = 0; i < 4; ++i)
        {
            // synth.addVoice (new SamplerSynthVoice()); // TODO make SamplerSynthVoice toPlay SamplerSynthSounds
            synth.addVoice (new SamplerVoice());    // and these ones play the sampled sounds
        }
        makeSoundsFromChops(audioReaderSource->getAudioFormatReader());
    }

    void makeSoundsFromChops(AudioFormatReader * audioFormatReader)
    {
        for (auto i = 0; i < chopTree.getNumChildren(); ++i) {
            auto chop = chopTree.getChild(i);
            auto tstart = chop.getProperty(PROP_START_TIME);
            auto tend = chop.getProperty(PROP_END_TIME);
            auto triggerNote = chop.getProperty(PROP_TRIGGER);

            AudioSubsectionReader audioSSReader (audioFormatReader, tstart, tend - tstart, false);
            BigInteger noteRange; /* substitute for triggerNote */
            noteRange.setRange (triggerNote, triggerNote, true);

            synth.clearSounds();
            synth.addSound (new SamplerSound (chop.getProperty(PROP_ID),
                                            audioSSReader,
                                            noteRange,
                                            74,   // root midi note
                                            0.1,  // attack time
                                            0.1,  // release time
                                            10.0  // maximum sample length
                                            ));
        }
    }

    void prepareToPlay (int /*samplesPerBlockExpected*/, double sampleRate) override
    {
        midiCollector.reset (sampleRate);
        synth.setCurrentPlaybackSampleRate (sampleRate);
    }

    void releaseResources() override {}

    void getNextAudioBlock (const AudioSourceChannelInfo& bufferToFill) override
    {
        // the synth always adds its output to the audio buffer, so we have to clear it
        // first..
        bufferToFill.clearActiveBufferRegion();

        // fill a midi buffer with incoming messages from the midi input.
        MidiBuffer incomingMidi;
        midiCollector.removeNextBlockOfMessages (incomingMidi, bufferToFill.numSamples);

        // pass these messages to the keyboard state so that it can update the component
        // to show on-screen which keys are being pressed on the physical midi keyboard.
        // This call will also add midi messages to the buffer which were generated by
        // the mouse-clicking on the on-screen keyboard.
        keyboardState.processNextMidiBuffer (incomingMidi, 0, bufferToFill.numSamples, true);

        // and now get the synth to process the midi events and generate its output.
        synth.renderNextBlock (*bufferToFill.buffer, incomingMidi, 0, bufferToFill.numSamples);
    }

    // TODO COPIED from Projucer Synth tutorial
    // this collects real-time midi messages from the midi input device, and
    // turns them into blocks that we can process in our audio callback
    MidiMessageCollector midiCollector;


private:

    // this represents the state of which keys on our on-screen keyboard are held
    // down. When the mouse is clicked on the keyboard component, this object also
    // generates midi messages for this, which we can pass on to our synth.
    MidiKeyboardState& keyboardState;

    // the synth itself!
    Synthesiser synth;
    // 

    ValueTree chopTree;


    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (SamplerAudioSource)
};
