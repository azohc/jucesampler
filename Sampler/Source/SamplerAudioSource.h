/*
  ==============================================================================

    SamplerAudioSource.h
    Created: 27 Mar 2020 9:20:18am
    Author:  azohc

  ==============================================================================
*/

#pragma once

#include "../JuceLibraryCode/JuceHeader.h"
#include "PluginProcessor.h"
#include "Constants.h"


//==============================================================================
/*
*/
class SamplerAudioSource    : public AudioSource
{
public:    
    SamplerAudioSource (MidiKeyboardState& keyState) : keyboardState (keyState)
    {
        synth.addVoice (new SamplerVoice());    // and these ones play the sampled sounds TODO voice counter modifier
    }

    void makeSoundsFromChops(AudioFormatReader* formatReader, ValueTree chopTree)
    {
        synth.clearSounds();
        for (auto i = 0; i < chopTree.getNumChildren(); ++i) {
            Chop chop (chopTree.getChild(i));
            int chopId = chop.getId();
            int64 startSample = chop.getStartSample();
            int64 endSample = chop.getEndSample();
            int rootNote = chop.getTriggerNote();
            auto audioSSReader = new AudioSubsectionReader (formatReader, startSample, endSample - startSample, false);
            double startTime = chop.getStartTime();
            double endTime = chop.getEndTime();

            BigInteger singleNote;
            singleNote.setBit(rootNote); // TODO  midi learn, connect MIDI keyboard
            auto sound = new SamplerSound (String (chopId), // ALL PARAMS IN SECONDS
                                           *audioSSReader,
                                           singleNote,     // notes the sound is triggered by
                                           rootNote,       // root note
                                           0.0,            // attack time
                                           0.0,            // release time
                                           endTime - startTime // maximum sample length
            );
            chopSounds.set (chopId, sound);
            synth.addSound (sound);
            delete audioSSReader;
        }
    }

    void prepareToPlay (int /*samplesPerBlockExpected*/, double sampleRate) override
    {
        midiCollector.reset (sampleRate);
        synth.setCurrentPlaybackSampleRate (sampleRate);
    }

    void releaseResources() override {}

    void getNextAudioBlock (const AudioSourceChannelInfo& bufferToFill) override
    {
        // the synth always adds its output to the audio buffer, so we have to clear it
        // first..
        bufferToFill.clearActiveBufferRegion();

        // fill a midi buffer with incoming messages from the midi input.
        MidiBuffer incomingMidi;
        midiCollector.removeNextBlockOfMessages (incomingMidi, bufferToFill.numSamples);

        // pass these messages to the keyboard state so that it can update the component
        // to show on-screen which keys are being pressed on the physical midi keyboard.
        // This call will also add midi messages to the buffer which were generated by
        // the mouse-clicking on the on-screen keyboard.
        keyboardState.processNextMidiBuffer (incomingMidi, 0, bufferToFill.numSamples, true);

        // and now get the synth to process the midi events and generate its output.
        synth.renderNextBlock (*bufferToFill.buffer, incomingMidi, 0, bufferToFill.numSamples);
    }

    void setChopsADSR(int chopId, juce::ADSR::Parameters params)
    {
        print("SETTING ADSR FOR CHOP " + String(chopId));
        // print(String::formatted("onset at %.3fms, %.3fs, frame %d\n", aubio_onset_get_last_ms(o), aubio_onset_get_last_s(o), aubio_onset_get_last(o)));
        print(String::formatted("PARAMS: %.3fs %.3fs %.3fs", params.attack, params.decay, params.release, params.sustain));
        auto sound = chopSounds[chopId];
        sound->setEnvelopeParameters(params);
    }

    HashMap<int, SamplerSound*>* getChopSoundsMap()
    {
        return &chopSounds;
    }
    
    MidiMessageCollector midiCollector;

private:
    MidiKeyboardState& keyboardState;
    Synthesiser synth;

    HashMap<int, SamplerSound*> chopSounds;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (SamplerAudioSource)
};
